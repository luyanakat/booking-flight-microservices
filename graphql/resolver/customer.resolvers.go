package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.30

import (
	"context"
	"mock-project/graphql/graph"
	"mock-project/graphql/graph/model"
	"mock-project/helper"
	"mock-project/middleware"
	pb "mock-project/pb/proto"
	"net/http"
	"strconv"
	"time"

	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// ChangePassword is the resolver for the changePassword field.
func (r *customerOpsResolver) ChangePassword(ctx context.Context, obj *model.CustomerOps, input *model.ChangePasswordInput) (*string, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, helper.GqlResponse("access denied", http.StatusForbidden)
	}
	if helper.CheckAdmin(user) {
		return nil, helper.GqlResponse("admin cannot change user password", http.StatusForbidden)
	}

	if !helper.CheckPasswordLength(input.NewPassword) {
		return nil, helper.GqlResponse("new password must be at least 8 characters", http.StatusBadRequest)
	}
	if !helper.CheckPasswordLength(input.OldPassword) {
		return nil, helper.GqlResponse("old password must be at least 8 characters", http.StatusBadRequest)
	}

	req := &pb.ChangePasswordRequest{
		OldPassword: input.OldPassword,
		NewPassword: input.NewPassword,
	}
	// send user email through metadata
	md := metadata.Pairs("user", user.Email)
	ctx = metadata.NewOutgoingContext(ctx, md)

	// customer gRPC
	pC, err := r.customerClient.ChangePassword(ctx, req)
	if err != nil {
		return nil, helper.GqlResponse(err.Error(), http.StatusInternalServerError)
	}

	return &pC.Email, nil
}

// UpdateCustomer is the resolver for the updateCustomer field.
func (r *customerOpsResolver) UpdateCustomer(ctx context.Context, obj *model.CustomerOps, input *model.UpdateCustomerInput) (*string, error) {
	user := middleware.GetUserFromContext(ctx)

	if user == nil {
		return nil, helper.GqlResponse("access denied", http.StatusForbidden)
	}

	date, err := helper.ConvertTime(*input.DateOfBirth)
	if err != nil {
		return nil, helper.GqlResponse(err.Error(), http.StatusInternalServerError)
	}

	err = helper.CheckCustomerInput(input)
	if err != nil {
		return nil, helper.GqlResponse(err.Error(), http.StatusBadRequest)
	}

	var a string
	if input.MemberCode == nil {
		a = ""
	}
	req := &pb.Customer{
		Name:           *input.Name,
		Email:          *input.Email,
		Address:        *input.Address,
		PhoneNumber:    *input.PhoneNumber,
		IdentifyNumber: *input.IdentifyNumber,
		DateOfBirth:    timestamppb.New(date),
		MemberCode:     a,
	}

	customer, err := r.customerClient.UpdateCustomer(ctx, req)
	if err != nil {
		return nil, helper.GqlResponse(err.Error(), http.StatusInternalServerError)
	}

	id := strconv.Itoa(int(customer.Id))
	return &id, nil
}

// Customers is the resolver for the customers field.
func (r *customerQueryResolver) Customers(ctx context.Context, obj *model.CustomerQuery, page *int, limit *int) (*model.CustomCustomerResponse, error) {
	user := middleware.GetUserFromContext(ctx)

	if user == nil {
		return nil, helper.GqlResponse("access denied", http.StatusForbidden)
	}

	if !helper.CheckAdmin(user) {
		return nil, helper.GqlResponse("user cannot access this resource", http.StatusForbidden)
	}

	req := &pb.ListCustomerRequest{
		Page:  int64(*page),
		Limit: int64(*limit),
	}

	res, err := r.customerClient.ListCustomer(ctx, req)
	if err != nil {
		return nil, helper.GqlResponse(err.Error(), http.StatusInternalServerError)
	}

	// append protobuf response to GraphQL response
	var customerRes []*model.Customer
	for _, customer := range res.CustomerList {
		customerQ := &model.Customer{}
		customerQ.ID = int(customer.Id)
		customerQ.Name = customer.Name
		customerQ.Email = customer.Email
		customerQ.Address = customer.Address
		customerQ.PhoneNumber = customer.PhoneNumber
		customerQ.IdentifyNumber = customer.IdentifyNumber
		customerQ.DateOfBirth = customer.DateOfBirth.AsTime().Format(time.RFC3339)
		customerQ.MemberCode = customer.MemberCode
		customerQ.CreatedAt = helper.GetTimePointer(customer.CreatedAt.AsTime())
		customerQ.UpdatedAt = helper.GetTimePointer(customer.UpdatedAt.AsTime())
		customerRes = append(customerRes, customerQ)
	}

	// graphQL response
	resQ := model.CustomCustomerResponse{
		Data:  customerRes,
		Page:  helper.GetIntPointer(int(res.Page)),
		Limit: limit,
		Total: helper.GetIntPointer(int(res.Total)),
	}
	return &resQ, nil
}

// Customer is the resolver for the Customer field.
func (r *mutationResolver) Customer(ctx context.Context) (*model.CustomerOps, error) {
	return &model.CustomerOps{}, nil
}

// Customer is the resolver for the Customer field.
func (r *queryResolver) Customer(ctx context.Context) (*model.CustomerQuery, error) {
	return &model.CustomerQuery{}, nil
}

// CustomerOps returns graph.CustomerOpsResolver implementation.
func (r *Resolver) CustomerOps() graph.CustomerOpsResolver { return &customerOpsResolver{r} }

// CustomerQuery returns graph.CustomerQueryResolver implementation.
func (r *Resolver) CustomerQuery() graph.CustomerQueryResolver { return &customerQueryResolver{r} }

type customerOpsResolver struct{ *Resolver }
type customerQueryResolver struct{ *Resolver }
